# üß† Error Knowledge Base

This document contains all known errors and their fixes, auto-generated by the Self-Healing AI system.

---

## ConnectionError: email_sender

**Error Message**: `Resend API connection timeout`

**Location**: `/root/modal_deploy.py:410`

**Root Cause**: The error occurs because the HTTP request to the Resend API is timing out, likely due to network latency, server overload, or insufficient timeout configuration. The default timeout settings may be too short for the current network conditions or the API response time.

**Fix**:

```python
Add proper timeout handling and retry logic to the email sending function:

```python
import requests
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def send_email():
    # Configure retry strategy
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    
    # Create session with retry adapter
    session = requests.Session()
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    try:
        # Make request with explicit timeout (connect, read)
        response = session.post(
            resend_api_url,
            json=email_data,
            headers=headers,
            timeout=(10, 30)  # 10s connect, 30s read timeout
        )
        return response
    except requests.exceptions.Timeout:
        # Log the timeout and handle gracefully
        print("Email API request timed out after retries")
        raise
    except requests.exceptions.ConnectionError as e:
        print(f"Connection error: {e}")
        raise
```

```

**Prevention**: Always implement proper timeout configuration (both connect and read timeouts), retry logic with exponential backoff, and comprehensive error handling for external API calls. Consider implementing circuit breaker patterns for critical services and monitor API response times to adjust timeout values appropriately.

**Confidence**: 90%

---

## ValueError: vapi_caller

**Error Message**: `Invalid phone number format`

**Location**: `/root/modal_deploy.py:320`

**Root Cause**: Phone number validation failed due to incorrect format

**Fix**:
```python

def validate_phone(phone_str):
    if not phone_str:
        return False, None, "No phone"
    cleaned = re.sub(r'\D', '', str(phone_str))
    if len(cleaned) < 10:
        return False, None, "Too short"
    if cleaned[-7:-4] == "555":
        return False, None, "Fake 555 number"
    return True, f"+1{cleaned[-10:]}", None

```

**Prevention**: Always validate and clean phone numbers before calling APIs

**Confidence**: 95%

---

## KeyError: cloud_drip_campaign

**Error Message**: `'company_name'`

**Location**: `/root/modal_deploy.py:580`

**Root Cause**: The error occurs because the code is trying to access a 'company_name' key from a lead dictionary that doesn't contain this key. This typically happens when the data structure being processed has inconsistent fields or when the expected data format doesn't match the actual input.

**Fix**:

```python
Replace the direct key access with a safe dictionary access method:

# Instead of:
company_name = lead['company_name']

# Use one of these approaches:
# Option 1: Use .get() with default value
company_name = lead.get('company_name', '')
# or
company_name = lead.get('company_name', 'Unknown Company')

# Option 2: Check if key exists first
if 'company_name' in lead:
    company_name = lead['company_name']
else:
    company_name = ''  # or handle the missing data appropriately

# Option 3: Use try-except for more complex error handling
try:
    company_name = lead['company_name']
except KeyError:
    company_name = ''  # or log the error and set default
```

**Prevention**: Always validate the structure of dictionaries before accessing keys, especially when dealing with external data sources. Consider implementing data validation schemas (using libraries like Pydantic or Cerberus) to ensure consistent data structure, and use defensive programming practices like .get() method or explicit key existence checks.

**Confidence**: 90%

---

## HTTPError: cloud_prospector

**Error Message**: `422 Unprocessable Entity - Apollo rate limit exceeded`

**Location**: `/root/modal_deploy.py:445`

**Root Cause**: Apollo.io API rate limit exceeded (~2000 requests/day on free tier)

**Fix**:

```python

# Add rate limiting and retry logic
import time
def apollo_request_with_retry(url, data, max_retries=3):
    for attempt in range(max_retries):
        resp = requests.post(url, json=data)
        if resp.status_code == 422:
            wait = 60 * (attempt + 1)  # Exponential backoff
            print(f"Rate limited, waiting {wait}s...")
            time.sleep(wait)
        else:
            return resp
    return None

```

**Prevention**: Implement request pacing (max 1 request/second) and fallback data sources

**Confidence**: 90%

---

## AttributeError: cloud_multi_touch

**Error Message**: `'NoneType' object has no attribute 'get'`

**Location**: `/root/modal_deploy.py:673`

**Root Cause**: Variable was None instead of dict when trying to access .get() method

**Fix**:

```python

# Always ensure variable is a dict before calling .get()
if not meta or not isinstance(meta, dict):
    meta = {}
# Then safely access
value = meta.get("key", "default")

```

**Prevention**: Add null checks before any .get() calls on potentially None variables

**Confidence**: 95%

---

## ConnectionError: email_sender

**Error Message**: `Resend API connection timeout`

**Location**: `/root/modal_deploy.py:410`

**Root Cause**: The error occurs because the HTTP request to the Resend API is timing out, likely due to network latency, server overload, or insufficient timeout configuration. The default timeout for requests may be too short for the current network conditions or API response times.

**Fix**:

```python
Add proper timeout handling and retry logic to the send_email function:

```python
import requests
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def send_email(...):
    # Configure retry strategy
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    
    # Create session with retry adapter
    session = requests.Session()
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    
    try:
        # Make request with explicit timeout (connect, read)
        response = session.post(
            resend_api_url,
            headers=headers,
            json=email_data,
            timeout=(10, 30)  # 10s connect, 30s read timeout
        )
        response.raise_for_status()
        return response.json()
        
    except requests.exceptions.Timeout:
        raise ConnectionError("Email service timeout - please try again later")
    except requests.exceptions.ConnectionError as e:
        raise ConnectionError(f"Failed to connect to email service: {str(e)}")
```

```

**Prevention**: Always set explicit timeouts for external API calls, implement exponential backoff retry logic, monitor API response times, and consider using circuit breaker patterns for critical services. Also, ensure your deployment environment has stable network connectivity to external services.

**Confidence**: 90%

---

## ValueError: vapi_caller

**Error Message**: `Invalid phone number format`

**Location**: `/root/modal_deploy.py:320`

**Root Cause**: Phone number validation failed due to incorrect format

**Fix**:
```python

def validate_phone(phone_str):
    if not phone_str:
        return False, None, "No phone"
    cleaned = re.sub(r'\D', '', str(phone_str))
    if len(cleaned) < 10:
        return False, None, "Too short"
    if cleaned[-7:-4] == "555":
        return False, None, "Fake 555 number"
    return True, f"+1{cleaned[-10:]}", None

```

**Prevention**: Always validate and clean phone numbers before calling APIs

**Confidence**: 95%

---

## KeyError: cloud_drip_campaign

**Error Message**: `'company_name'`

**Location**: `/root/modal_deploy.py:580`

**Root Cause**: The code is trying to access the 'company_name' key from a lead dictionary, but this key doesn't exist in the dictionary. This typically happens when the data structure changes, the key is named differently, or the lead data is incomplete/malformed.

**Fix**:

```python
Replace the direct dictionary access with a safe get() method or add validation:

# Option 1: Use get() with default value
company_name = lead.get('company_name', 'Unknown Company')

# Option 2: Use get() with None check
company_name = lead.get('company_name')
if company_name is None:
    # Handle missing company name appropriately
    continue  # or skip this lead, or use default

# Option 3: Add validation before access
if 'company_name' not in lead:
    print(f"Warning: Lead missing company_name: {lead}")
    continue
company_name = lead['company_name']
```

**Prevention**: Always use defensive programming when accessing dictionary keys: use dict.get() method with default values, validate required keys exist before processing, and implement proper error handling for malformed data. Consider adding data validation/schema checks when receiving lead data from external sources.

**Confidence**: 90%

---

## HTTPError: cloud_prospector

**Error Message**: `422 Unprocessable Entity - Apollo rate limit exceeded`

**Location**: `/root/modal_deploy.py:445`

**Root Cause**: Apollo.io API rate limit exceeded (~2000 requests/day on free tier)

**Fix**:

```python

# Add rate limiting and retry logic
import time
def apollo_request_with_retry(url, data, max_retries=3):
    for attempt in range(max_retries):
        resp = requests.post(url, json=data)
        if resp.status_code == 422:
            wait = 60 * (attempt + 1)  # Exponential backoff
            print(f"Rate limited, waiting {wait}s...")
            time.sleep(wait)
        else:
            return resp
    return None

```

**Prevention**: Implement request pacing (max 1 request/second) and fallback data sources

**Confidence**: 90%

---

## AttributeError: cloud_multi_touch

**Error Message**: `'NoneType' object has no attribute 'get'`

**Location**: `/root/modal_deploy.py:673`

**Root Cause**: Variable was None instead of dict when trying to access .get() method

**Fix**:

```python

# Always ensure variable is a dict before calling .get()
if not meta or not isinstance(meta, dict):
    meta = {}
# Then safely access
value = meta.get("key", "default")

```

**Prevention**: Add null checks before any .get() calls on potentially None variables

**Confidence**: 95%

---

## ValueError: test_source

**Error Message**: `Test error for self-healer`

**Location**: `C:\Users\nearm\.gemini\antigravity\scratch\empire-unified\modules\self_healer.py:466`

**Root Cause**: This is an intentionally raised ValueError at line 466 in the self_healer.py module. The error message 'Test error for self-healer' indicates this is a deliberate test error, likely used for testing the self-healing functionality of the system. The error is raised at the module level (in <module>), meaning it occurs during module import or execution.

**Fix**:

```python
Remove or comment out the test error line:

# Line 466 in self_healer.py - remove this line:
# raise ValueError("Test error for self-healer")

Or wrap it in a conditional check:

if __name__ == '__main__' and os.getenv('ENABLE_TEST_ERROR', 'false').lower() == 'true':
    raise ValueError("Test error for self-healer")
```

**Prevention**: Use environment variables or command-line flags to control test errors instead of hardcoding them. Implement proper test isolation by keeping test errors in separate test files or behind feature flags. Consider using logging with different levels instead of raising exceptions for testing purposes.

**Confidence**: 95%

---

## SilentFailure: auto_outreach_loop (Feb 9, 2026)

**Error Message**: `No outreach sent for 10 days despite "successful" deployment`

**Location**: `workers/outreach.py:199-203` (auto_outreach_loop)

**Root Cause**: All leads in `contacts_master` had been moved to non-contactable statuses (outreach_sent, contacted, failed). The outreach loop queries `status IN ('new', 'research_done')` and found 0 matching leads. The function executed successfully every 5 minutes but printed "No leads ready for outreach" and exited without error.

**Fix**:

```python
# Reset leads to re-enable outreach:
sb.table("contacts_master").update({"status": "new"}).in_(
    "status", ["outreach_sent", "outreach_dispatched", "contacted", "failed", "no_contact_info"]
).execute()

# PREVENTION: Add lead recycling CRON
@app.function(schedule=modal.Cron("0 0 * * *"))
def recycle_stale_leads():
    cutoff = (datetime.now(timezone.utc) - timedelta(days=7)).isoformat()
    supabase.table("contacts_master").update({"status": "new"}).in_(
        "status", ["outreach_sent", "no_response"]
    ).lt("updated_at", cutoff).execute()
```

**Prevention**: Add a contactable lead count check to the system_heartbeat CRON. Alert when count drops below 10. Implement automatic lead recycling after 7 days of no response.

**Confidence**: 100% (Verified root cause via database query)

---

## EnvironmentError: Missing SUPABASE_URL (Feb 9, 2026)

**Error Message**: `Database connection failed - SUPABASE_URL not set`

**Location**: `.env` file and Modal secrets

**Root Cause**: The `.env` file had `NEXT_PUBLIC_SUPABASE_URL` but NOT `SUPABASE_URL`. Different modules reference different variable names. Backend code uses `SUPABASE_URL` while frontend uses `NEXT_PUBLIC_SUPABASE_URL`.

**Fix**:

```env
# Both MUST exist in .env:
NEXT_PUBLIC_SUPABASE_URL=https://rzcpfwkygdvoshtwxncs.supabase.co
SUPABASE_URL=https://rzcpfwkygdvoshtwxncs.supabase.co
```

**Prevention**: When adding environment variables, always check ALL code paths that reference database URLs. Use a centralized config module that falls back: `os.environ.get("SUPABASE_URL") or os.environ.get("NEXT_PUBLIC_SUPABASE_URL")`.

**Confidence**: 100%

---

## DeploymentError: CRON Limit Exceeded (Feb 9, 2026)

**Error Message**: `Deployment failed: reached limit of 5 cron jobs (# already deployed => 2, # in this app => 4)`

**Location**: Modal CLI during `modal deploy deploy.py`

**Root Cause**: Modal workspace has a hard 5-CRON limit. Stopped apps still hold CRON slots. Previous deployments and orphaned apps (`test-deploy-delete-me`, `empire-command-center`, old `ghl-omni-automation`) were holding stale CRON slots even after being stopped.

**Fix**:

1. Stop ALL stale apps by App ID (not name): `python -m modal app stop <app-id>`
2. Stop the existing `ghl-omni-automation` to clear its stale CRONs
3. Reduce CRONs in `deploy.py` ‚Äî remove lowest priority CRON (`trigger_self_learning_loop`)
4. User Rule: **Max 4 CRONs, not 5** ‚Äî using 5 causes instability
5. Redeploy fresh

**Prevention**: Before every deploy, run `python -m modal app list --json` and count total CRONs across ALL apps. Keep our app at 3 CRONs max (heartbeat, outreach, lead_sync). Use `--json` flag to avoid Windows Unicode rendering issues.

**Confidence**: 100%

---

## SMS Silent Failure: SCRAPED_ GHL Contact IDs (Feb 9, 2026)

**Error Message**: `dispatch_sms_logic.local()` throws exception silently (caught by except block)

**Location**: `workers/outreach.py` ‚Üí `auto_outreach_loop` ‚Üí SMS dispatch path

**Root Cause**: 444/615 leads (72%) have fake `ghl_contact_id` values like `SCRAPED_e1dbae35` instead of real GHL IDs. The `dispatch_sms_logic` function sends these to the GHL webhook, which rejects them. The error is caught by the `except` block, printed, and `continue` skips to the next lead ‚Äî meaning email never fires as a fallback.

**Fix**:

1. Added `SCRAPED_` prefix check in `dispatch_sms_logic` ‚Äî returns False immediately instead of crashing
2. Changed outreach loop routing: SMS now requires `has_real_ghl` flag (no SCRAPED_ prefix)
3. If SMS returns False or throws exception, falls through to email instead of skipping
4. Added `traceback.print_exc()` for full error stack in logs

**Prevention**: Always check `ghl_contact_id` for `SCRAPED_` prefix before calling any GHL webhook. Only 171/615 leads have real GHL IDs.

**Confidence**: 100%

---

## GHL API 401 Unauthorized ‚Äî PIT Token Scope Insufficient (Feb 9, 2026)

**Error Message**: `{"statusCode":401,"message":"The token is not authorized for this scope."}`

**Location**: Any call to `https://services.leadconnectorhq.com/contacts/` or other GHL v2 API endpoints

**Root Cause**: The $99/month GHL plan only provides a Private Integration Token (PIT) with insufficient scopes. Both GET and POST requests to the Contacts API return 401. The PIT (`pit-1bc9b50a...`) cannot read or write contacts. This is a plan limitation, not a code bug.

**Fix**:

> [!CAUTION]
> **OWNER DIRECTIVE: DO NOT USE GHL API. It is unreliable on the $99 plan.**

```text
BANNED:   GHL API (all endpoints) ‚Äî returns 401 on $99 plan
APPROVED: GHL webhooks ‚Äî for SMS dispatch to contacts with real GHL IDs only
PRIMARY:  Resend API ‚Äî for all email sending (tracked: opens, clicks, bounces)
PLAN:     Migrate away from GHL entirely
```

**Prevention**: Never write code that calls `services.leadconnectorhq.com` directly. Use GHL webhooks (`hooks/RnK4OjX0oDcqtWw0VyLr/webhook-trigger/...`) for SMS only. For emails, use Resend API. The `scripts/enrich_ghl_contacts.py` script is archived ‚Äî it cannot work on the current plan.

**Confidence**: 100% (verified both GET and POST return 401)

---

## Vercel: Stale/Ghost Deployment ‚Äî Code Pushed But Not Live

**Error Message**: Changes committed and pushed to GitHub but NOT appearing on the live Vercel site

**Symptoms**:

- `git log` shows the latest commit
- `git status` says "up to date with origin/master"
- Live site still shows OLD version (missing components, old footer, etc.)
- No obvious build errors in Vercel dashboard

**Root Cause**: Vercel's GitHub auto-deploy webhook sometimes silently fails to trigger. The code is in the repo but Vercel never received the webhook to start a new build. This has happened MULTIPLE times across projects (AI Service Co, LakelandFinds).

**Fix**:

```bash
# Force a production deploy from the CLI
npx -y vercel --prod --yes
```

**Prevention Checklist** ‚Äî After EVERY `git push`, verify the deploy actually happened:

1. Check Vercel dashboard for a new deployment timestamp
2. If no new deployment within 2 minutes, run `npx -y vercel --prod --yes`
3. Hard refresh the live site (Ctrl+Shift+R) to bypass browser cache
4. Verify the specific changes are visible (don't just check "site loads")

**Key Lesson**: `git push` ‚â† deployed. Always verify the specific changes you made are actually visible on the live site. Exit code 0 on push means nothing ‚Äî check the actual rendered page.

**Confidence**: 100% (hit this Feb 10, 2026 on LakelandFinds ‚Äî VAPI widget + newsletter missing despite code being pushed)

---

## Vapi Call Notifications Not Arriving (FIXED ‚Äî Feb 11, 2026)

**Symptom**: Dan calls Sarah, hangs up, never receives call report SMS.

**Root Cause (CONFIRMED by Modal logs)**:

```
üì± [NOTIFY] === NOTIFICATION BLOCK REACHED for +13529368152 ===
üì± [NOTIFY] ‚ùå FAILED: NameError: name 'json' is not defined
```

Two bugs in sequence:

1. `json` module not imported in `vapi_webhook` function ‚Äî `json.dumps()` crashed the notification
2. `updated_at` column doesn't exist on `customer_memory` ‚Äî upsert crashed (but notification was outside try/except)

**Fix**:

1. Added `import json` to `vapi_webhook` function (line 532 of deploy.py)
2. Removed `updated_at` from upsert payload
3. Previously also removed `customer_name` from upsert (same issue)

**How we found it**: Dan clicked the `end-of-call-report` webhook call in Modal dashboard ‚Üí logs showed the exact error.

**Key lesson**: When Modal functions use local imports, ALL needed modules must be imported inside the function. The function had `import re` but not `import json`. Always check Modal logs FIRST ‚Äî we spent 3 board calls theorizing when the answer was in one log line.

**Also fixed in same session**: phone number serverUrls, Vapi assistant serverUrls, Michael‚ÜíDan name fix, question tracking.

**Confidence**: 100% ‚Äî Dan confirmed notifications working after fix

---

## SMS "Michael" Name Override (FIXED ‚Äî Feb 11, 2026)

**Error**: Sarah calls every customer "Michael" regardless of what they say their name is.

**Root Cause**: Line 399 of `deploy.py` had `updated_context["contact_name"] = contact_name` which blindly overwrote with GHL's `contact_name` on EVERY message. GHL had "Michael" for Dan's contact.

**Fix**:

1. Cleared "Michael" ‚Üí "Dan" in `context_summary` via direct DB update
2. Changed code: user's stated name (extracted via regex) takes priority over GHL's contact_name
3. GHL's name only used as initial fallback for new customers with no existing name

**Confidence**: 95% (DB verified, code deployed, but not re-tested by Dan)

---

## customer_name and updated_at Column Crashes in Upsert (FIXED ‚Äî Feb 11, 2026)

**Error**: `deploy.py` upsert to `customer_memory` included `customer_name` AND `updated_at` fields, but NEITHER column exists on the table.

**Modal log proof**: `APIError: Could not find the 'updated_at' column of 'customer_memory' in the schema cache (PGRST204)`

**Impact**: Supabase returns 400 error on every `end-of-call-report` upsert. The try/except catches it but voice memory doesn't persist.

**Fix**: Removed both `customer_name` and `updated_at` from the upsert payload. Only `phone_number` and `context_summary` remain.

**Lesson**: ALWAYS verify table schema before writing. Use `sb.table('x').select('*').limit(1).execute()` to see actual columns.

**Confidence**: 100% (Modal log confirmed, both columns removed, upsert now succeeds)

---

## Phone Number serverUrl Pointing to Dead Endpoint (FIXED ‚Äî Feb 11, 2026)

**Error**: Multiple Vapi phone numbers had `serverUrl` pointing to old `empire-inbound-vapi-webhook.modal.run` which no longer exists.

**Affected numbers**: +18636928474, +18633373601, +18633373705, +19045129565, +18636928548, and one with no number.

**Impact**: Calls to these numbers sent webhooks to a dead URL. In Vapi, phone-level serverUrl OVERRIDES assistant-level serverUrl.

**Fix**: Updated all phone number serverUrls via Vapi API PATCH.

**Confidence**: 100% (API verified post-fix)

---

## Anti-Hallucination Protocol (NEW ‚Äî Feb 11, 2026)

**Problem**: AI board calls were being hallucinated ‚Äî claimed API calls to other AIs never actually happened.

**Fix**: Board calls now use `scripts/board_call.py` which:

1. Makes real HTTP requests to Grok (xAI), ChatGPT (OpenAI), Gemini (Google)
2. Logs every request/response to `scripts/board_receipts.txt` with timestamps, HTTP codes, response IDs
3. If an API key is missing, logs `NO API KEY AVAILABLE` instead of faking a response
4. Dan can verify any board call by checking receipts file

**Verification**: Ask Dan "did you receive the board responses?" and check receipt files exist with real HTTP 200 responses.

**Confidence**: 100% (3 successful board calls verified with receipts)

---

## Email Replies Bouncing: <dan@aiserviceco.com> Has No Inbox

**Date**: 2026-02-12

**Error Message**: `550 5.1.1 The Gmail account that you tried to reach does not exist`

**Location**: Resend emails sent via `outreach.py` and `deploy.py`

**Root Cause**: `dan@aiserviceco.com` is a **Resend sending alias ONLY** ‚Äî it has no inbox. When leads reply, their email goes to `dan@aiserviceco.com` which bounces. The `reply_to` header was added as a fix but Gmail sometimes ignores it (e.g., when sender/recipient share the same domain, or when the "from" address is configured as a Gmail alias).

**Fix**: Changed ALL `from_email` defaults from `dan@aiserviceco.com` to `owner@aiserviceco.com` (Dan's real inbox). Changed in 7 places:

- `outreach.py` lines 173, 203, 333, 731 (4 instances)
- `deploy.py` lines 1360, 1405, 1547-1548 (3 instances)

Also added `reply_to: owner@aiserviceco.com` to all 3 email payloads in `outreach.py` as belt-and-suspenders.

**Key Rule**: NEVER send from an address that doesn't have a real inbox. Resend domain verification ‚â† inbox existence.

**Verification**: Dan tested reply and confirmed it lands in `owner@aiserviceco.com` ‚úÖ

**Confidence**: 100% (Dan-verified)

---

## 26% Email Bounce Rate ‚Äî Validation + Rate Limiting Fix

**Date**: 2026-02-12

**Error Message**: Resend dashboard showed 26.13% bounce rate (158 transient + 33 permanent)

**Location**: `outreach.py` `dispatch_email_logic()` and `auto_outreach_loop()`

**Root Cause**: Two issues:

1. **No email validation** ‚Äî sending to invalid, disposable, and role-based addresses
2. **300 emails/hr send rate** ‚Äî overwhelming recipient servers causing transient bounces

**Fix**:

1. Added `is_valid_email()` function that blocks bad patterns, disposable domains (mailinator, yopmail, etc.), and role-based prefixes (info@, admin@, support@)
2. Reduced batch sizes: 10 fresh + 15 follow-up ‚Üí **5 fresh + 5 follow-up** per cycle (max 60/hr)
3. In `resend_webhook`: permanent bounces auto-mark leads as `status = bad_email`
4. Invalid emails caught pre-send also get `status = bad_email`

**Key Rule**: Always validate email before sending. Rate limit to prevent transient bounces. Auto-purge permanent bounces.

**Verification**: Post-deploy system check passed ‚Äî 24 touches in 30 min, 317 lead pool, heartbeat active ‚úÖ

**Confidence**: 95% (bounce rate reduction requires 24-48 hrs to fully measure)

---

## Vapi Webhook 500: Prompt Braces & Escaped Docstrings

**Date**: 2026-02-13

**Error Message**: `500 Internal Server Error` (Returned to Vapi dashboard)

**Location**: `deploy.py` `vapi_webhook` and `modules/voice/sales_persona.py`

**Root Cause**:

1. **Syntax Error**: Escaped docstrings (`\"\"\"`) in `sales_persona.py` broke the module import.
2. **Formatting Crash**: Using `.format()` on AI prompts containing curly braces (e.g., code snippets or internal logic placeholders) causes a `TypeError`.
3. **Telemetry Overhead**: Vapi sends high-volume telemetry events like `speech-update` which were causing unnecessary overhead and potential crashes during high-concurrency periods.

**Fix**:

1. Fixed syntax in `sales_persona.py`.
2. Migrated `get_persona_prompt` from `.format()` to `.replace()` for absolute safety against unintended braces.
3. Implemented a "Universal 200 OK" safety wrapper in `vapi_webhook` that catches all errors and returns a valid JSON response instead of a 500.
4. Added a "Fast Exit" for telemetry events.

**Key Rule**: Never use `.format()` for AI prompts. Always wrap webhooks in a total safety `try-except` to prevent 500 errors from breaking 3rd-party integrations.

**Verification**: Remote mock tests for `assistant.started` and `assistant-request` verified 200 OK and correct configuration payload. ‚úÖ

**Confidence**: 100%

---

## Stale Heartbeats: Missing `check_type` Schema Field

**Date**: 2026-02-13

**Error Message**: Heartbeats stopped appearing in Supabase `system_health_log`.

**Location**: `deploy.py` `system_heartbeat`

**Root Cause**: The Supabase table `system_health_log` has a mandatory (or at least expected) `check_type` column. The insertion code was missing this field, causing the database to reject the row.

**Fix**: Added `"check_type": "heartbeat_v3"` to the insert statement.

**Key Rule**: Database schema changes are silent killers. Always verify mandatory fields when heartbeats or logs stop flowing.

**Verification**: Log entries verified in Supabase after redeploy. ‚úÖ

**Confidence**: 100%

---

## Maya Prompt Hallucination: "Supplies for a Dentist" (FIXED ‚Äî Feb 19, 2026)

**Error Message**: Maya told a dental prospect she could help with "getting supplies" ‚Äî a service AI Service Co doesn't offer.

**Location**: `modules/voice/sales_persona.py` (MAYA_EXPLAINER_PROMPT v4) and `deploy.py` Vapi webhook `assistant-request` handler

**Root Cause**: The old Maya v4 prompt said "You are Maya, a Business Consultant for AI Service Company" with NO product list or grounding. When a dentist called, Maya had no anchor for what she actually sells, so she confabulated based on conversational context ‚Äî inventing capabilities that don't exist.

**Critical lesson**: **AI prompts without explicit product boundaries will hallucinate capabilities.** A vague role like "Business Consultant" gives the LLM permission to make up any service.

**Fix (Maya v5)**:

1. Replaced vague "Business Consultant" with explicit: "AI Sales Rep for AI Service Co ‚Äî builds AI receptionists, automated review systems, and lead generation tools"
2. Added hard product list with need-matching table: missed calls ‚Üí AI Receptionist, bad reviews ‚Üí Review Automation, hiring pain ‚Üí AI Screener, no leads ‚Üí Lead Gen
3. Added explicit rule: "PRICING: NEVER quote a dollar amount. Dan handles ALL pricing."
4. Added Dan recognition: +13529368152 triggers "Hey boss!" greeting
5. Updated `firstMessage` in Vapi handler to say "I'm Maya with AI Service Co" (was generic)

**Key Rule**: Every AI persona prompt MUST include:

- Explicit company name and what it sells
- A bounded product list (so it can't invent services)
- Clear handoff rules (who closes, what NOT to discuss)
- Boss/owner recognition by phone number

**Prevention**: When updating persona prompts, always ask: "If a random business calls, does the prompt tell Maya EXACTLY what she sells and what she doesn't?" If not, she will confabulate.

**Confidence**: 100% (root cause confirmed ‚Äî v4 had zero product grounding)

---

## Vapi firstMessage Ignored Dynamic Context (FIXED ‚Äî Feb 19, 2026)

**Error**: Maya's opening greeting was always the same generic "Thank you for connecting, I'm Maya..." regardless of who called ‚Äî even Dan.

**Location**: `deploy.py` line 827 (assistant-request handler)

**Root Cause**: The `firstMessage` was a static string with a ternary check (`if is_maya_call else None`). It never checked the caller's phone number or name, so Dan and strangers got the same greeting.

**Fix**: Made `firstMessage` dynamic based on caller identity:

```python
DAN_PHONE = "+13529368152"
if caller_phone == DAN_PHONE:
    maya_first = "Hey boss! What's going on? Who are we impressing today?"
elif customer_name:
    maya_first = f"Hey {customer_name}! Thanks for calling, I'm Maya with AI Service Co."
else:
    maya_first = "Hey! Thanks for calling, I'm Maya with AI Service Co."
```

**Key Rule**: `firstMessage` in Vapi is the FIRST thing the user hears ‚Äî it sets the entire tone. Always make it contextual (returning customer vs. new, boss vs. stranger).

**Confidence**: 100%

---

## Maya Memory Architecture (Reference ‚Äî Feb 19, 2026)

**How Maya remembers callers across calls:**

| Phase | What happens | Code location |
|-------|-------------|---------------|
| Call starts | Vapi sends `assistant-request` event | `deploy.py` line 752 |
| Memory lookup | Queries `customer_memory` by caller phone | `deploy.py` lines 754-777 |
| Context injection | Loads `contact_name`, `business_type`, `history`, `questions_asked` into prompt | `deploy.py` lines 790-795 |
| Call ends | Vapi sends `end-of-call-report` | `deploy.py` (later in function) |
| Memory save | Upserts transcript + extracted context back to `customer_memory` | `deploy.py` end-of-call handler |

**Limitation**: History capped at last 1000 chars (line 794). Memory is per-phone-number only ‚Äî same person calling from different number = new stranger.

**Table schema**: `customer_memory` has `phone_number` (PK), `context_summary` (JSONB with history, contact_name, business_type, etc.)

---

## Manus AI Hallucinated Lead Data (CRITICAL ‚Äî Feb 19, 2026)

**Error**: Imported 1000 "Jacksonville business leads" from Manus AI share link. Only ~60 were real businesses. **940 were hallucinated** ‚Äî fake company names, fake phone numbers, fake emails generated to pad the list to 1000.

**Impact**: System attempted to call/email fake businesses, burning Vapi credits on invalid numbers and damaging sender reputation with bounced emails to non-existent addresses.

**Signs the data was fake (in hindsight)**:

- Business names followed a pattern: `[LastName] [Category] [Suffix]` (e.g., "Smith Gutter Installer Services", "Rodriguez Tree Trimmer Pros", "Jackson Pool Cleaner Experts")
- Emails all followed `info@[businessname].com` pattern ‚Äî too uniform for real scraped data
- Phone numbers were all 904 area code but many didn't connect
- All calls returned FAILED status immediately

**Fix Applied**:

1. All 476 imported leads marked `status='bad_data'` ‚Äî removed from outreach queue
2. Outbound calls gated behind `has_real_ghl` check ‚Äî scraped leads can't trigger Vapi calls
3. SMS already required real GHL ID ‚Äî was already protected

**MANDATORY: Lead Import Validation Checklist (before ANY future import)**:

| Source credibility | Is this from a verified scraper (Google Places, Yelp) or an AI? | AI-generated = REJECT |
| Name diversity | Do names follow a pattern or look natural? | Pattern = suspect |
| Email domain check | Do email domains resolve (MX record lookup)? | No MX = fake |
| Phone spot-check | Call 5 random numbers manually before bulk import | 0/5 connect = fake |
| Dedup ratio | If >50% already in DB, list may be recycled junk | High overlap = suspect |
| Business verification | Google 5 random company names from the list | Not found = fake |

**Root Cause**: Manus AI (like all LLMs) will hallucinate data to fulfill a request. When asked for "1000 Jacksonville businesses," it found ~60 real ones and fabricated 940 to meet the target. **Never trust AI-generated lead lists without validation.**

**Confidence**: 100%

---

## Supabase RLS / Service Role Key Trap (CRITICAL ‚Äî Feb 20, 2026)

**Error**: Modal background functions (workers/prospectors) were querying Supabase and receiving **0 records/leads** despite the database being full.

**Symptom**: `leads.count` returns `0` but `SELECT count(*) FROM contacts_master` in the Supabase SQL editor returns a high number.

**Discovery**:
Supabase **Row Level Security (RLS)** defaults to blocking all access unless a policy is defined.

- The `anon` key (used by default in some snippets) is subject to RLS.
- The `service_role` key (secret) **bypasses RLS**.

**Fix**:

1. Go to **Supabase Dashboard -> Settings -> API**.
2. Copy the **service_role** secret key (starts with `eyJ...J9...`).
3. Update Modal secrets: `modal secret create agency-vault SUPABASE_KEY="[service_role_key]"`.
4. Deploy: `modal deploy deploy.py`.

**Rule**: Always use `service_role` for backend workers. `anon` is solely for frontend client-side code where RLS policies explicitly allow user-level access.

**Confidence**: 100%

---

## DeploymentError: Modal Endpoint Limit Exceeded (Feb 20, 2026)

**Error Message**: `Deployment failed: reached limit of 8 endpoints` (Exit code: 1)

**Location**: Modal CLI during `modal deploy deploy.py`

**Root Cause**: The Modal Starter plan allows a maximum of 8 web endpoints. Adding the `dispatch_review_api` pushed the count to 9, causing the deploy to reject.

**Fix**:

1. Consolidated the new dashboard functionality into the existing `sovereign_stats` endpoint.
2. Modified `sovereign_stats` to return a unified JSON object containing `stats`, `dispatch_board`, and `review_stats`.
3. Updated `dashboard.html` to fetch all data from this single source.

**Prevention**: Keep a running count of `@app.function()` methods with `@modal.web_endpoint` or `@modal.asgi_app`. If approaching 8, consolidate data into unified "stats" or "management" endpoints using action parameters or unified return objects.

**Confidence**: 100% (Verified deploy success after consolidation)
