# ðŸ§  Error Knowledge Base

This document contains all known errors and their fixes, auto-generated by the Self-Healing AI system.

---

## ConnectionError: email_sender

**Error Message**: `Resend API connection timeout`

**Location**: `/root/modal_deploy.py:410`

**Root Cause**: The error occurs because the HTTP request to the Resend API is timing out, likely due to network latency, server overload, or insufficient timeout configuration. The default timeout settings may be too short for the current network conditions or the API response time.

**Fix**:

```python
Add proper timeout handling and retry logic to the email sending function:

```python
import requests
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def send_email():
    # Configure retry strategy
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    
    # Create session with retry adapter
    session = requests.Session()
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    try:
        # Make request with explicit timeout (connect, read)
        response = session.post(
            resend_api_url,
            json=email_data,
            headers=headers,
            timeout=(10, 30)  # 10s connect, 30s read timeout
        )
        return response
    except requests.exceptions.Timeout:
        # Log the timeout and handle gracefully
        print("Email API request timed out after retries")
        raise
    except requests.exceptions.ConnectionError as e:
        print(f"Connection error: {e}")
        raise
```

```

**Prevention**: Always implement proper timeout configuration (both connect and read timeouts), retry logic with exponential backoff, and comprehensive error handling for external API calls. Consider implementing circuit breaker patterns for critical services and monitor API response times to adjust timeout values appropriately.

**Confidence**: 90%

---

## ValueError: vapi_caller

**Error Message**: `Invalid phone number format`

**Location**: `/root/modal_deploy.py:320`

**Root Cause**: Phone number validation failed due to incorrect format

**Fix**:
```python

def validate_phone(phone_str):
    if not phone_str:
        return False, None, "No phone"
    cleaned = re.sub(r'\D', '', str(phone_str))
    if len(cleaned) < 10:
        return False, None, "Too short"
    if cleaned[-7:-4] == "555":
        return False, None, "Fake 555 number"
    return True, f"+1{cleaned[-10:]}", None

```

**Prevention**: Always validate and clean phone numbers before calling APIs

**Confidence**: 95%

---

## KeyError: cloud_drip_campaign

**Error Message**: `'company_name'`

**Location**: `/root/modal_deploy.py:580`

**Root Cause**: The error occurs because the code is trying to access a 'company_name' key from a lead dictionary that doesn't contain this key. This typically happens when the data structure being processed has inconsistent fields or when the expected data format doesn't match the actual input.

**Fix**:

```python
Replace the direct key access with a safe dictionary access method:

# Instead of:
company_name = lead['company_name']

# Use one of these approaches:
# Option 1: Use .get() with default value
company_name = lead.get('company_name', '')
# or
company_name = lead.get('company_name', 'Unknown Company')

# Option 2: Check if key exists first
if 'company_name' in lead:
    company_name = lead['company_name']
else:
    company_name = ''  # or handle the missing data appropriately

# Option 3: Use try-except for more complex error handling
try:
    company_name = lead['company_name']
except KeyError:
    company_name = ''  # or log the error and set default
```

**Prevention**: Always validate the structure of dictionaries before accessing keys, especially when dealing with external data sources. Consider implementing data validation schemas (using libraries like Pydantic or Cerberus) to ensure consistent data structure, and use defensive programming practices like .get() method or explicit key existence checks.

**Confidence**: 90%

---

## HTTPError: cloud_prospector

**Error Message**: `422 Unprocessable Entity - Apollo rate limit exceeded`

**Location**: `/root/modal_deploy.py:445`

**Root Cause**: Apollo.io API rate limit exceeded (~2000 requests/day on free tier)

**Fix**:

```python

# Add rate limiting and retry logic
import time
def apollo_request_with_retry(url, data, max_retries=3):
    for attempt in range(max_retries):
        resp = requests.post(url, json=data)
        if resp.status_code == 422:
            wait = 60 * (attempt + 1)  # Exponential backoff
            print(f"Rate limited, waiting {wait}s...")
            time.sleep(wait)
        else:
            return resp
    return None

```

**Prevention**: Implement request pacing (max 1 request/second) and fallback data sources

**Confidence**: 90%

---

## AttributeError: cloud_multi_touch

**Error Message**: `'NoneType' object has no attribute 'get'`

**Location**: `/root/modal_deploy.py:673`

**Root Cause**: Variable was None instead of dict when trying to access .get() method

**Fix**:

```python

# Always ensure variable is a dict before calling .get()
if not meta or not isinstance(meta, dict):
    meta = {}
# Then safely access
value = meta.get("key", "default")

```

**Prevention**: Add null checks before any .get() calls on potentially None variables

**Confidence**: 95%

---

## ConnectionError: email_sender

**Error Message**: `Resend API connection timeout`

**Location**: `/root/modal_deploy.py:410`

**Root Cause**: The error occurs because the HTTP request to the Resend API is timing out, likely due to network latency, server overload, or insufficient timeout configuration. The default timeout for requests may be too short for the current network conditions or API response times.

**Fix**:

```python
Add proper timeout handling and retry logic to the send_email function:

```python
import requests
import time
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def send_email(...):
    # Configure retry strategy
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    
    # Create session with retry adapter
    session = requests.Session()
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount('http://', adapter)
    session.mount('https://', adapter)
    
    try:
        # Make request with explicit timeout (connect, read)
        response = session.post(
            resend_api_url,
            headers=headers,
            json=email_data,
            timeout=(10, 30)  # 10s connect, 30s read timeout
        )
        response.raise_for_status()
        return response.json()
        
    except requests.exceptions.Timeout:
        raise ConnectionError("Email service timeout - please try again later")
    except requests.exceptions.ConnectionError as e:
        raise ConnectionError(f"Failed to connect to email service: {str(e)}")
```

```

**Prevention**: Always set explicit timeouts for external API calls, implement exponential backoff retry logic, monitor API response times, and consider using circuit breaker patterns for critical services. Also, ensure your deployment environment has stable network connectivity to external services.

**Confidence**: 90%

---

## ValueError: vapi_caller

**Error Message**: `Invalid phone number format`

**Location**: `/root/modal_deploy.py:320`

**Root Cause**: Phone number validation failed due to incorrect format

**Fix**:
```python

def validate_phone(phone_str):
    if not phone_str:
        return False, None, "No phone"
    cleaned = re.sub(r'\D', '', str(phone_str))
    if len(cleaned) < 10:
        return False, None, "Too short"
    if cleaned[-7:-4] == "555":
        return False, None, "Fake 555 number"
    return True, f"+1{cleaned[-10:]}", None

```

**Prevention**: Always validate and clean phone numbers before calling APIs

**Confidence**: 95%

---

## KeyError: cloud_drip_campaign

**Error Message**: `'company_name'`

**Location**: `/root/modal_deploy.py:580`

**Root Cause**: The code is trying to access the 'company_name' key from a lead dictionary, but this key doesn't exist in the dictionary. This typically happens when the data structure changes, the key is named differently, or the lead data is incomplete/malformed.

**Fix**:

```python
Replace the direct dictionary access with a safe get() method or add validation:

# Option 1: Use get() with default value
company_name = lead.get('company_name', 'Unknown Company')

# Option 2: Use get() with None check
company_name = lead.get('company_name')
if company_name is None:
    # Handle missing company name appropriately
    continue  # or skip this lead, or use default

# Option 3: Add validation before access
if 'company_name' not in lead:
    print(f"Warning: Lead missing company_name: {lead}")
    continue
company_name = lead['company_name']
```

**Prevention**: Always use defensive programming when accessing dictionary keys: use dict.get() method with default values, validate required keys exist before processing, and implement proper error handling for malformed data. Consider adding data validation/schema checks when receiving lead data from external sources.

**Confidence**: 90%

---

## HTTPError: cloud_prospector

**Error Message**: `422 Unprocessable Entity - Apollo rate limit exceeded`

**Location**: `/root/modal_deploy.py:445`

**Root Cause**: Apollo.io API rate limit exceeded (~2000 requests/day on free tier)

**Fix**:

```python

# Add rate limiting and retry logic
import time
def apollo_request_with_retry(url, data, max_retries=3):
    for attempt in range(max_retries):
        resp = requests.post(url, json=data)
        if resp.status_code == 422:
            wait = 60 * (attempt + 1)  # Exponential backoff
            print(f"Rate limited, waiting {wait}s...")
            time.sleep(wait)
        else:
            return resp
    return None

```

**Prevention**: Implement request pacing (max 1 request/second) and fallback data sources

**Confidence**: 90%

---

## AttributeError: cloud_multi_touch

**Error Message**: `'NoneType' object has no attribute 'get'`

**Location**: `/root/modal_deploy.py:673`

**Root Cause**: Variable was None instead of dict when trying to access .get() method

**Fix**:

```python

# Always ensure variable is a dict before calling .get()
if not meta or not isinstance(meta, dict):
    meta = {}
# Then safely access
value = meta.get("key", "default")

```

**Prevention**: Add null checks before any .get() calls on potentially None variables

**Confidence**: 95%

---

## ValueError: test_source

**Error Message**: `Test error for self-healer`

**Location**: `C:\Users\nearm\.gemini\antigravity\scratch\empire-unified\modules\self_healer.py:466`

**Root Cause**: This is an intentionally raised ValueError at line 466 in the self_healer.py module. The error message 'Test error for self-healer' indicates this is a deliberate test error, likely used for testing the self-healing functionality of the system. The error is raised at the module level (in <module>), meaning it occurs during module import or execution.

**Fix**:

```python
Remove or comment out the test error line:

# Line 466 in self_healer.py - remove this line:
# raise ValueError("Test error for self-healer")

Or wrap it in a conditional check:

if __name__ == '__main__' and os.getenv('ENABLE_TEST_ERROR', 'false').lower() == 'true':
    raise ValueError("Test error for self-healer")
```

**Prevention**: Use environment variables or command-line flags to control test errors instead of hardcoding them. Implement proper test isolation by keeping test errors in separate test files or behind feature flags. Consider using logging with different levels instead of raising exceptions for testing purposes.

**Confidence**: 95%

---

## SilentFailure: auto_outreach_loop (Feb 9, 2026)

**Error Message**: `No outreach sent for 10 days despite "successful" deployment`

**Location**: `workers/outreach.py:199-203` (auto_outreach_loop)

**Root Cause**: All leads in `contacts_master` had been moved to non-contactable statuses (outreach_sent, contacted, failed). The outreach loop queries `status IN ('new', 'research_done')` and found 0 matching leads. The function executed successfully every 5 minutes but printed "No leads ready for outreach" and exited without error.

**Fix**:

```python
# Reset leads to re-enable outreach:
sb.table("contacts_master").update({"status": "new"}).in_(
    "status", ["outreach_sent", "outreach_dispatched", "contacted", "failed", "no_contact_info"]
).execute()

# PREVENTION: Add lead recycling CRON
@app.function(schedule=modal.Cron("0 0 * * *"))
def recycle_stale_leads():
    cutoff = (datetime.now(timezone.utc) - timedelta(days=7)).isoformat()
    supabase.table("contacts_master").update({"status": "new"}).in_(
        "status", ["outreach_sent", "no_response"]
    ).lt("updated_at", cutoff).execute()
```

**Prevention**: Add a contactable lead count check to the system_heartbeat CRON. Alert when count drops below 10. Implement automatic lead recycling after 7 days of no response.

**Confidence**: 100% (Verified root cause via database query)

---

## EnvironmentError: Missing SUPABASE_URL (Feb 9, 2026)

**Error Message**: `Database connection failed - SUPABASE_URL not set`

**Location**: `.env` file and Modal secrets

**Root Cause**: The `.env` file had `NEXT_PUBLIC_SUPABASE_URL` but NOT `SUPABASE_URL`. Different modules reference different variable names. Backend code uses `SUPABASE_URL` while frontend uses `NEXT_PUBLIC_SUPABASE_URL`.

**Fix**:

```env
# Both MUST exist in .env:
NEXT_PUBLIC_SUPABASE_URL=https://rzcpfwkygdvoshtwxncs.supabase.co
SUPABASE_URL=https://rzcpfwkygdvoshtwxncs.supabase.co
```

**Prevention**: When adding environment variables, always check ALL code paths that reference database URLs. Use a centralized config module that falls back: `os.environ.get("SUPABASE_URL") or os.environ.get("NEXT_PUBLIC_SUPABASE_URL")`.

**Confidence**: 100%

---

## DeploymentError: CRON Limit Exceeded (Feb 9, 2026)

**Error Message**: `Deployment failed: reached limit of 5 cron jobs (# already deployed => 2, # in this app => 4)`

**Location**: Modal CLI during `modal deploy deploy.py`

**Root Cause**: Modal workspace has a hard 5-CRON limit. Stopped apps still hold CRON slots. Previous deployments and orphaned apps (`test-deploy-delete-me`, `empire-command-center`, old `ghl-omni-automation`) were holding stale CRON slots even after being stopped.

**Fix**:

1. Stop ALL stale apps by App ID (not name): `python -m modal app stop <app-id>`
2. Stop the existing `ghl-omni-automation` to clear its stale CRONs
3. Reduce CRONs in `deploy.py` â€” remove lowest priority CRON (`trigger_self_learning_loop`)
4. User Rule: **Max 4 CRONs, not 5** â€” using 5 causes instability
5. Redeploy fresh

**Prevention**: Before every deploy, run `python -m modal app list --json` and count total CRONs across ALL apps. Keep our app at 3 CRONs max (heartbeat, outreach, lead_sync). Use `--json` flag to avoid Windows Unicode rendering issues.

**Confidence**: 100%

---

## SMS Silent Failure: SCRAPED_ GHL Contact IDs (Feb 9, 2026)

**Error Message**: `dispatch_sms_logic.local()` throws exception silently (caught by except block)

**Location**: `workers/outreach.py` â†’ `auto_outreach_loop` â†’ SMS dispatch path

**Root Cause**: 444/615 leads (72%) have fake `ghl_contact_id` values like `SCRAPED_e1dbae35` instead of real GHL IDs. The `dispatch_sms_logic` function sends these to the GHL webhook, which rejects them. The error is caught by the `except` block, printed, and `continue` skips to the next lead â€” meaning email never fires as a fallback.

**Fix**:

1. Added `SCRAPED_` prefix check in `dispatch_sms_logic` â€” returns False immediately instead of crashing
2. Changed outreach loop routing: SMS now requires `has_real_ghl` flag (no SCRAPED_ prefix)
3. If SMS returns False or throws exception, falls through to email instead of skipping
4. Added `traceback.print_exc()` for full error stack in logs

**Prevention**: Always check `ghl_contact_id` for `SCRAPED_` prefix before calling any GHL webhook. Only 171/615 leads have real GHL IDs.

**Confidence**: 100%

---

## GHL API 401 Unauthorized â€” PIT Token Scope Insufficient (Feb 9, 2026)

**Error Message**: `{"statusCode":401,"message":"The token is not authorized for this scope."}`

**Location**: Any call to `https://services.leadconnectorhq.com/contacts/` or other GHL v2 API endpoints

**Root Cause**: The $99/month GHL plan only provides a Private Integration Token (PIT) with insufficient scopes. Both GET and POST requests to the Contacts API return 401. The PIT (`pit-1bc9b50a...`) cannot read or write contacts. This is a plan limitation, not a code bug.

**Fix**:

> [!CAUTION]
> **OWNER DIRECTIVE: DO NOT USE GHL API. It is unreliable on the $99 plan.**

```text
BANNED:   GHL API (all endpoints) â€” returns 401 on $99 plan
APPROVED: GHL webhooks â€” for SMS dispatch to contacts with real GHL IDs only
PRIMARY:  Resend API â€” for all email sending (tracked: opens, clicks, bounces)
PLAN:     Migrate away from GHL entirely
```

**Prevention**: Never write code that calls `services.leadconnectorhq.com` directly. Use GHL webhooks (`hooks/RnK4OjX0oDcqtWw0VyLr/webhook-trigger/...`) for SMS only. For emails, use Resend API. The `scripts/enrich_ghl_contacts.py` script is archived â€” it cannot work on the current plan.

**Confidence**: 100% (verified both GET and POST return 401)

---
